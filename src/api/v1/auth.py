from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from fastapi.security import OAuth2PasswordRequestForm
import pyotp
import qrcode
import io
import base64

from src.db.session import get_db
from src.schemas.user import UserCreate, UserResponse, Token, TOTPVerify, TOTPSetupResponse
from src.models.user import User
from src.services.crypto_service import crypto_service
from src.core.security import create_access_token
from src.api.dependencies import SessionDep, get_current_user

router = APIRouter()

@router.post("/register", response_model=UserResponse)
async def register(user_in: UserCreate, db: SessionDep):
    """Register a new user."""
    result = await db.execute(select(User).where(User.username == user_in.username))
    if result.scalars().first():
        raise HTTPException(status_code=400, detail="Username already registered")
        
    # Generate user-specific DEK
    plain_dek, encrypted_dek = crypto_service.generate_user_dek()
    # Hash password
    hashed_pwd = crypto_service.hash_password(user_in.password)
    
    # Are we the first user? Making the first user an admin.
    total_users = await db.execute(select(User))
    is_admin = len(total_users.scalars().all()) == 0

    new_user = User(
        username=user_in.username,
        password_hash=hashed_pwd,
        encrypted_dek=encrypted_dek,
        is_admin=is_admin
    )
    db.add(new_user)
    await db.commit()
    await db.refresh(new_user)
    
    return new_user

@router.post("/login", response_model=Token)
async def login(form_data: OAuth2PasswordRequestForm = Depends(), db: AsyncSession = Depends(get_db)):
    """OAuth2 compatible token login, getting an access token for future requests."""
    result = await db.execute(select(User).where(User.username == form_data.username))
    user = result.scalars().first()
    
    if not user or not crypto_service.verify_password(user.password_hash, form_data.password):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    # Check 2FA if TOTP is configured
    if user.totp_secret:
        # Client MUST pass the 2FA token as 'client_secret' in the OAuth2 form, or we can use custom field
        totp_code = form_data.client_secret
        if not totp_code:
            raise HTTPException(status_code=400, detail="2FA token required in client_secret field")
            
        # Decrypt TOTP Secret using Master -> DEK -> Secret chain
        # Wait, login doesn't inherently need the DEK to be exposed everywhere, 
        # but to verify TOTP, we need to decrypt the user's TOTP secret.
        # But wait, how do we get the plain DEK? It is generated by master key!
        plain_totp_secret = crypto_service.decrypt_user_secret(user.encrypted_dek, user.totp_secret)
        totp = pyotp.TOTP(plain_totp_secret)
        if not totp.verify(totp_code):
            raise HTTPException(status_code=401, detail="Invalid 2FA code")
            
    access_token = create_access_token(subject=str(user.id), is_admin=user.is_admin)
    return {"access_token": access_token, "token_type": "bearer"}

@router.post("/2fa/setup", response_model=TOTPSetupResponse)
async def setup_2fa(current_user: User = Depends(get_current_user), db: AsyncSession = Depends(get_db)):
    """Generate a new TOTP secret and QR code URL for the user to set up 2FA."""
    if current_user.totp_secret:
        raise HTTPException(status_code=400, detail="2FA is already set up")
        
    secret = pyotp.random_base32()
    totp = pyotp.TOTP(secret)
    provisioning_uri = totp.provisioning_uri(name=current_user.username, issuer_name="BinanceBotV3")
    
    # We shouldn't save the secret to DB yet. The user needs to verify it first.
    # In a real app, this pending secret would be in Redis. For simplicity, we just return it.
    
    return TOTPSetupResponse(secret=secret, qr_code_url=provisioning_uri)

@router.post("/2fa/verify")
async def verify_and_enable_2fa(
    verify_data: TOTPVerify, 
    secret: str, # passed as query param for the initial setup validation
    current_user: User = Depends(get_current_user), 
    db: AsyncSession = Depends(get_db)):
    """Verify the TOTP code and enable 2FA if correct."""
    if current_user.totp_secret:
        raise HTTPException(status_code=400, detail="2FA is already enabled")
        
    totp = pyotp.TOTP(secret)
    if not totp.verify(verify_data.token):
        raise HTTPException(status_code=400, detail="Invalid 2FA code")
        
    # The code was valid! Encrypt the totp secret with user's DEK and save it
    # We need to decrypt the user's DEK first to get the plain DEK to encrypt the TOTP secret!
    # Wait, CryptoService needs a method to just decrypt the DEK?
    # Yes. Let's add that to crypto_service for internal use.
    
    plain_dek = crypto_service._master_fernet.decrypt(current_user.encrypted_dek.encode()).decode()
    encrypted_totp = crypto_service.encrypt_with_dek(plain_dek, secret)
    
    current_user.totp_secret = encrypted_totp
    db.add(current_user)
    await db.commit()
    
    return {"msg": "2FA successfully enabled"}
